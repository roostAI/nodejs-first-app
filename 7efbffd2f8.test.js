// Test generated by RoostGPT for test NodeUnitTest using AI Type Open AI and AI Model gpt-4

import {jest} from '@jest/globals';
import request from 'supertest';
import express from "express";
import path from "path";
import mongoose from "mongoose";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import User from './models/User';
import app from './index';

jest.mock('./models/User');

describe('POST /login', () => {
  beforeAll(() => {
    mongoose.connect("mongodb://localhost/testDB", { useNewUrlParser: true, useUnifiedTopology: true });
  });

  afterEach(() => {
    User.findOne.mockClear();
  });

  afterAll(() => {
    mongoose.connection.close();
  });

  test('should redirect to /register if user does not exist', async () => {
    User.findOne.mockResolvedValue(null);
    const res = await request(app).post('/login').send({ email: 'test@test.com', password: 'password' });
    expect(res.header.location).toBe('/register');
  });

  test('should render login page with error message if password does not match', async () => {
    const mockUser = { password: 'hashedpassword' };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(false);
    const res = await request(app).post('/login').send({ email: 'test@test.com', password: 'wrongpassword' });
    expect(res.text).toContain('Incorrect Password');
  });

  test('should set a cookie and redirect to / if login is successful', async () => {
    const mockUser = { _id: '123', password: 'hashedpassword' };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);
    const res = await request(app).post('/login').send({ email: 'test@test.com', password: 'password' });
    expect(res.header['set-cookie']).toBeDefined();
    expect(res.header.location).toBe('/');
  });
});
